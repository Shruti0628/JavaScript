How JS works/runs?

1. JS code 
2. Parsing ---> Lexical Parser (converts program down to tokens)
               |__ Syntax Parser ( Checks for syntax and create AST(parse tree) if correct)

3. Compilation (JIT Compilation) -> converts JS code into machine code/byte code
4. Execution Phase ( In execution phase, we've call stack with 1. Creation Phase, 2. Execution Contexts and Heap Memory)
5. Final Output


Q.1. Difference between AOT and JIT?

Ans: The difference is AOT (Ahead of Time) compilation means your whole source code is compile first and results executable runs. Whereas, JIT means (Just-In-Time) where your source code gets compiled in the runtime and gets optimized for hotspots.
        ---ANALOGY---
Suppose, in our childhood days, when teacher use to give us homeworks for current chapter, a group of students use to do the following chapter exercise as welll to reduce the load the next day. So, doing the exercise of following chapter is basically AOT.
Whereas, when a group of students use to do the following chapter exercise on the same day when it is taught then, that's JIT.

Q.2. Why JS is often referred as a hybrid language?

Ans: It's a hybrid interpreter and compiler because modern engines blends both approaches for optimal performance
Code is parsed and executed line by line for quick startup, and also uses JIT compilation to convert hotspots into faster machine codes at runtime, resulting in a balance fast loading with high speed for complex apps.

Q.3. What is execution phase?

Ans: Once, code is compiled JS engine executes that. During execution, engine creates execution contexts, manages scope chain, handles var assignments, and call functions.
The EXECUTION CONTEXT has 2 phases: 
|__ Creation Phase ( where var and functions are hoisted ) Also, it creates GEC and its pushed to call stack. 
|__ Execution Phase ( where code actually runs )


The JS uses a "call stack" to keep track of the EXECUTION CONTEXT. When a function is called, a new frame is added to the stack, and when that completes, its frame is removed in a LIFO order (Last-In-First-Out)
---CALL STACK---
In order to manage execution contexts, the JS uses a call stack. 

Q.4. What is a call stack?

Ans: The call stack is a data structure that keeps track of currently executing functions in a program. It operates on LIFO principle, meaning last function added to the stack gets executed first and gets completed.

Q.5. What is a heap memory?

Ans: Heap memory is where dyanmically allocated memory resides. This is where objects, closures, and other dynamically allocaated data are stored. While call stack manages flow of execution and functio contexts, heap memory holds data that is referenced by these execution contexts.


# Synchronous code: It's the code that executes line by line blocking further execution until each line is completed.
# Asynchronous code: It's the code that allows other code to continue executing while it waits for an asynchronous operation to complete.

Global Execution Context: Here, we get to know about global objects, "this" keyword, outer scope and memory allocation(hoisting)

Web APIS: It's provided by the browser and contains TIMERS, DOM, AJAX/API CALLS, AND OTHERS Asynchronous

Event Loop : It's work is to check and pass operations remaining in CALLBACK QUEUE, checking if call stack is empty or not.

                        --------Hoisting---------
Hoisting is a JS mechanism where var and functions declarations are moved to the top of their scope before code executes. This means that no matter where functions and var are declared, they are moved to top of their scope regardless of whether their scope is global or local.
Also, a point to remember is these 2 points:
1. Whenever we are declaring variables under "let" and "const" they can never be hoisted because they remain in block scope.
2. If we use fat arrow functions, again it can not be hoisted it needs to be declared and defined.


                        -------Scope in JS--------
The scope in JS refers to the context in which var are declared and accessed. It defines the visibility and lifetime of var. When a var is declared, it's bound to a specific scope, and it's accessibility is determined by that scope.
Function and Block Scope can be referred as "Local Scope" as well.

# Lexical Scoping: Lexical scoping in JS is like a set of rules that determines where a variable can be used in your code. It follows the physical structure of your code, so if a var is declared inside a function or block, it can be used only within that function or block.
It works like manager.

# Scope Chaining: It is the process by which JS, when looking for the value of a var checks current scope and then looks in outer(enclosing)scopes until it finds var or reaches global scope. In scope chaining, inner child can access it's parent's data but vice-versa isn't allowed.

# Global Variable V/S Local Variable
Global Variable: A var declared in global scope is referred to as a global var. It has global visibility and can be accessed from anywhere in the code.
Local Variable: A var declared within a function or a block is often referred to as a local var. It has local visibility, limited to function or block where it's declared.

                        -------Closures-----
A closure is created when an inner function has access to variables of it's outer function, even after outer function has finished executing;.
And since, the execution context gets removed once its executed getting access of the variable is done by referencing to the heap memory. The heap memory stores the data and returns when required. Objects, clousres and other dynamically allocated datas are stored.

Eg:
function multiplier(factor){
        return function(number){
                console.log(number, factor);
                return number * factorl
        };
}
const double = multiplier(2);
console.log(double(5));


                        ------Destructuring - Modern JS-----
Destructuring in JS is a way to extract values from arrays or array of objects and assign them to variables in a concise & readable manner.
Use Case: Makes code cleaner and avoids repetitive copying of values.

# Destructuring Arrays:
It makes possible to unpack values from arrays or properties from objects, into distinct variables. That's we can extract data from arrays & objects and assign them to variables.

# Extracting specific elements:
const no = [10,20,30];
const [ first, second, third ] = numbers;
console.log(first);
Also, you can ignore elements and access only the element that you want
const[ , , third ] = numbers;
console.log(third);

# WAP to swap two variables without using a third variable
let a = 10;
let b = 30;
[a,b] = [b,a];
console.log(a,b);

# Destructuring Objects:
const user = {
        name: "Shruti",
        age: 22,
        gender: "F"
};
const { name, age, gender } = user;
console.log(name);

// Renaming Properties:
const { name: fullName, age } = user;
console.log(fullName);


                -----SPREAD OPERATOR-----
JS ES6 (ECMAScript 6) introduced spread operator. The syntax for this is (...) 3 dots followed by the array or iterable.

# Copying an Array
let fruits = ["Apple", "Orange", "Mango","Banana"];
let newFruits = [...fruits];
console.log(newFruits);

# Concatenate Arrays
const num1 = [1,2,3];
const num2 = [4,5,6];
const num3 = [...num1, ...num2];
console.log(num3);

# Adding elements to an existing array:
let fruits = ["Apple", "Banana", "Mango"]
fruits.push(...["Guavava", "Grapes"])
console.log(fruits);

!! NOTE !!
In JS, when you use a spread operator to spread a string it converts the string into an array of its individual characters.
const country = "NEPAL";

// Traditional way
console.log(country.split(""));

// New way using ... (spread operator)
console.log([...country]);

                -----REST PARAMETERS-----
                
Here, the rest parameters syntax allows a function to accept an indefinite no of arguments as an array, providing more flexibility to work with 
functions that can accept varying no of arguments. We use ... (3 dots) in function within paranthesis or arg then it's called as  rest parameters. There is a difference between spread and rest parameters.

Eg: Here, is a traditional approach v/s rest parameters approach of doing sum.

# Traditional approach:  
const sum = (a,b,c,d)=>{
         return a+b+c+d;
};
console.log(sum(1,2,3,4,5));

# Rest parameters approach:
const sum = (...numbers) => {
       return numbers.reduce((accum,currVal) => (accum = accum + currVal),0); 
};
console.log(sum(1,2,3,4,5));

# NOTE:
Whenever we are working with rest parameters, a function definition can only have one rest parameter, and the rest parameter is generally written in the last (similar to default arg as written) in the function definition. Because, rest parameters will conclude everything at once or sum up.

                ---- EXPONENTIAL METHODS----
Exponentiation operator is represented by a double asterisk **. The operator can be only used with numeric values.
Eg: 
        base = 2
        exponent = 3
        console.log("Using Exponentiation method", base ** exponent) // This will result into 2*2*2

                -----STRING PADDING-----
String padding in JS is a way to add extra characters (like spaces) to a string to make it a specific length.
Eg: const companyName = "Yatra";
const paddedName = companyName.padStart(20);
console.log(paddedName);
padEnd(20) -> take similar example as given above and it will give me spaces at end.

                ---TRAILING COMMAS---
These are used to dynamically add values, or arg as per required alright.
Eg: const sum (temp1, temp2, temp3.)=>{
        return temp1+temp2+temp3;
}       

                -----Array.flat & Array.flatMap-----
flat() is a new array instance method that can create a one-dimensional array from a multidimensional array.
Eg:
        const nestedArray = [1,2[3,4],5];
        const flattenedArray = nestedArray.flat(); // nestedArray.flat(2) -> this will remove 2 nested arrays within a single array alright like [1,[2,[3,4],5]]
        console.log(flattenedArray); // It will show as [1,2,3,4,5];

flatMap() is a new Array instance method that combines flat() with map(). It's useful when calling a function that returns an array in the map() callback, but you want your resulted array to be flat.
Eg:
        const arr = ["My name", "is Shruti", "Rouniyar"];
        const newArr = arr.flatMap((currVal)=>currVal.split(" "));
        console.log(newArr); // Will show output as: ['My', 'name', 'is', 'Shruti', 'Rouniyar'];


                ----Object.fromEntries()----
Objects have an entries(). It returns an array containing all the object own properties, as an array of [key,value] pairs:
Eg:
        const person = {
                name: "Shruti",
                age: 22
        };
        const entries = Object.entries(person);
        console.log(entries); // [[ 'name', 'Shruti'], ['age', 22]]

        const newPerson = Object.fromEntries(entries);
        console.log(newPerson); // {name: 'Shruti', age: 22}

                ------Symbol.prototype.description------
In JS, a Symbol is a primitive data type introduced in ES6. It represents a unique identifier that is immutable and guaranteed to be unique. Symbols are often used as property keys in objects to avoid naming conflicts.

                -----Optional Catch Binding-----
In ES10, a new feature called "optional catch binding" was introducedd for the try...catch statement. This feature allows you to omit parameter in the catch block, making it optional.
Eg: 
        Earlier, we used to write:
        try{
                // Code block for catching error
        } catch(e){
                // Handling error
        }

        Using optional parameter:
        try{
                // Code block for catching error
        } catch{
                // Handling error
        }

                -----Nullish Coalescing Operator(??) -----
In JS, nullish coalescing operator(??) is a logical operator that provides a concise way to handle nullis ( null or undefined ) values. It returns its right-hand operand when it's left-hand operand is null or undefined, otherwise it returns left-hand operand.
Eg: 
        let num = 0; //falsy
        new_num = num ?? 10;
        console.log( new_num ); // Here, since its num=0, that's a falsy value then it's output will be 0 alright.

                -----Optional Chaining Operator(?.)-----
It provides a concise way to access properties of an object without worrying about existence of intermediate properties. It's particulary useful when working with nested objects or accessing properties of objects that maybe null or undefined.
Eg:
        const person = {
                name: "Shruti",
                address: {
                        city: "Biratnagar",
                        zipcode: 55613,
                        province: "Koshi"
                },
                age: 22,
                gender: "F"
        };

        // Accessing the city without using Optional Chaining
        const city = person.address ? person.address.city : "City unknown";
        console.log(city); 

        // Accessing with the help of optional chaining method
        const city1 = person.address ?. city : "City is unknown";
        console.log(city1);