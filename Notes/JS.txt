How JS works/runs?

1. JS code 
2. Parsing ---> Lexical Parser (converts program down to tokens)
               |__ Syntax Parser ( Checks for syntax and create AST(parse tree) if correct)

3. Compilation (JIT Compilation) -> converts JS code into machine code/byte code
4. Execution Phase ( In execution phase, we've call stack with 1. Creation Phase, 2. Execution Contexts and Heap Memory)
5. Final Output


Q.1. Difference between AOT and JIT?

Ans: The difference is AOT (Ahead of Time) compilation means your whole source code is compile first and results executable runs. Whereas, JIT means (Just-In-Time) where your source code gets compiled in the runtime and gets optimized for hotspots.
        ---ANALOGY---
Suppose, in our childhood days, when teacher use to give us homeworks for current chapter, a group of students use to do the following chapter exercise as welll to reduce the load the next day. So, doing the exercise of following chapter is basically AOT.
Whereas, when a group of students use to do the following chapter exercise on the same day when it is taught then, that's JIT.

Q.2. Why JS is often referred as a hybrid language?

Ans: It's a hybrid interpreter and compiler because modern engines blends both approaches for optimal performance
Code is parsed and executed line by line for quick startup, and also uses JIT compilation to convert hotspots into faster machine codes at runtime, resulting in a balance fast loading with high speed for complex apps.

Q.3. What is execution phase?

Ans: Once, code is compiled JS engine executes that. During execution, engine creates execution contexts, manages scope chain, handles var assignments, and call functions.
The EXECUTION CONTEXT has 2 phases: 
|__ Creation Phase ( where var and functions are hoisted ) Also, it creates GEC and its pushed to call stack. 
|__ Execution Phase ( where code actually runs )


The JS uses a "call stack" to keep track of the EXECUTION CONTEXT. When a function is called, a new frame is added to the stack, and when that completes, its frame is removed in a LIFO order (Last-In-First-Out)
---CALL STACK---
In order to manage execution contexts, the JS uses a call stack. 

Q.4. What is a call stack?

Ans: The call stack is a data structure that keeps track of currently executing functions in a program. It operates on LIFO principle, meaning last function added to the stack gets executed first and gets completed.

Q.5. What is a heap memory?

Ans: Heap memory is where dyanmically allocated memory resides. This is where objects, closures, and other dynamically allocaated data are stored. While call stack manages flow of execution and functio contexts, heap memory holds data that is referenced by these execution contexts.


# Synchronous code: It's the code that executes line by line blocking further execution until each line is completed.
# Asynchronous code: It's the code that allows other code to continue executing while it waits for an asynchronous operation to complete.

Global Execution Context: Here, we get to know about global objects, "this" keyword, outer scope and memory allocation(hoisting)

Web APIS: It's provided by the browser and contains TIMERS, DOM, AJAX/API CALLS, AND OTHERS Asynchronous

Event Loop : It's work is to check and pass operations remaining in CALLBACK QUEUE, checking if call stack is empty or not.

                        --------Hoisting---------
Hoisting is a JS mechanism where var and functions declarations are moved to the top of their scope before code executes. This means that no matter where functions and var are declared, they are moved to top of their scope regardless of whether their scope is global or local.
Also, a point to remember is these 2 points:
1. Whenever we are declaring variables under "let" and "const" they can never be hoisted because they remain in block scope.
2. If we use fat arrow functions, again it can not be hoisted it needs to be declared and defined.


                        -------Scope in JS--------
The scope in JS refers to the context in which var are declared and accessed. It defines the visibility and lifetime of var. When a var is declared, it's bound to a specific scope, and it's accessibility is determined by that scope.
Function and Block Scope can be referred as "Local Scope" as well.

# Lexical Scoping: Lexical scoping in JS is like a set of rules that determines where a variable can be used in your code. It follows the physical structure of your code, so if a var is declared inside a function or block, it can be used only within that function or block.
It works like manager.

# Scope Chaining: It is the process by which JS, when looking for the value of a var checks current scope and then looks in outer(enclosing)scopes until it finds var or reaches global scope. In scope chaining, inner child can access it's parent's data but vice-versa isn't allowed.

# Global Variable V/S Local Variable
Global Variable: A var declared in global scope is referred to as a global var. It has global visibility and can be accessed from anywhere in the code.
Local Variable: A var declared within a function or a block is often referred to as a local var. It has local visibility, limited to function or block where it's declared.

                        -------Closures-----
A closure is created when an inner function has access to variables of it's outer function, even after outer function has finished executing;.
And since, the execution context gets removed once its executed getting access of the variable is done by referencing to the heap memory. The heap memory stores the data and returns when required. Objects, clousres and other dynamically allocated datas are stored.

Eg:
function multiplier(factor){
        return function(number){
                console.log(number, factor);
                return number * factorl
        };
}
const double = multiplier(2);
console.log(double(5));


                        ------Destructuring - Modern JS-----
Destructuring in JS is a way to extract values from arrays or array of objects and assign them to variables in a concise & readable manner.
Use Case: Makes code cleaner and avoids repetitive copying of values.

# Destructuring Arrays:
It makes possible to unpack values from arrays or properties from objects, into distinct variables. That's we can extract data from arrays & objects and assign them to variables.

# Extracting specific elements:
const no = [10,20,30];
const [ first, second, third ] = numbers;
console.log(first);
Also, you can ignore elements and access only the element that you want
const[ , , third ] = numbers;
console.log(third);

# WAP to swap two variables without using a third variable
let a = 10;
let b = 30;
[a,b] = [b,a];
console.log(a,b);

# Destructuring Objects:
const user = {
        name: "Shruti",
        age: 22,
        gender: "F"
};
const { name, age, gender } = user;
console.log(name);

// Renaming Properties:
const { name: fullName, age } = user;
console.log(fullName);


                -----SPREAD OPERATOR-----
JS ES6 (ECMAScript 6) introduced spread operator. The syntax for this is (...) 3 dots followed by the array or iterable.

# Copying an Array
let fruits = ["Apple", "Orange", "Mango","Banana"];
let newFruits = [...fruits];
console.log(newFruits);

# Concatenate Arrays
const num1 = [1,2,3];
const num2 = [4,5,6];
const num3 = [...num1, ...num2];
console.log(num3);

# Adding elements to an existing array:
let fruits = ["Apple", "Banana", "Mango"]
fruits.push(...["Guavava", "Grapes"])
console.log(fruits);

!! NOTE !!
In JS, when you use a spread operator to spread a string it converts the string into an array of its individual characters.
const country = "NEPAL";

// Traditional way
console.log(country.split(""));

// New way using ... (spread operator)
console.log([...country]);